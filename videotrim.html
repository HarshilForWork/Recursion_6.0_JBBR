<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Trimmer</title>
    <link rel="stylesheet" href="static/styles/trimmer.css" />
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
  </head>
  <body class="container">
    <section class="leftbar" id="leftbar">
      <div class="section-title">
        <h2 class="grad">Video Library</h2>
      </div>

      <div class="video-list" id="video-list"></div>
    </section>

    <section class="centre" id="centre">
      <div class="section-title main-title">
        <h2 class="grad">Video Trimmer</h2>
      </div>

      <div class="video-container">
        <video id="video" controls>
          <source src="" type="video/mp4" />
          Your browser does not support the video tag.
        </video>
      </div>

      <div class="time-display">
        <span id="start-time">00:00</span>
        <span id="end-time">00:00</span>
      </div>

      <div class="timeline">
        <div class="video-progress" id="video-progress"></div>
        <div class="trim-handle start" id="start-handle"></div>
        <div class="trim-region" id="trim-region"></div>
        <div class="trim-handle end" id="end-handle"></div>
      </div>

      <div class="controls">
        <button id="play-trimmed">Play Trimmed Section</button>
        <button id="reset-trim">Reset Trim</button>
        <button id="download-btn" disabled class="btn-shadow">
          Download video
        </button>
        <button id="toggle-sidebar">Toggle Panels</button>
        <span id="loading" class="loading">Processing video...</span>
      </div>
    </section>

    <section class="rightbar" id="rightbar">
      <div class="section-title">
        <h2 class="grad">Upload to YT</h2>
      </div>
      <div class="right-content">
        <button id="signin-btn" onclick="handleAuthClick()">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="48"
            height="48"
            viewBox="0 0 48 48"
          >
            <path
              fill="#ffc107"
              d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917"
            />
            <path
              fill="#ff3d00"
              d="m6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691"
            />
            <path
              fill="#4caf50"
              d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238A11.9 11.9 0 0 1 24 36c-5.202 0-9.619-3.317-11.283-7.946l-6.522 5.025C9.505 39.556 16.227 44 24 44"
            />
            <path
              fill="#1976d2"
              d="M43.611 20.083H42V20H24v8h11.303a12.04 12.04 0 0 1-4.087 5.571l.003-.002l6.19 5.238C36.971 39.205 44 34 44 24c0-1.341-.138-2.65-.389-3.917"
            />
          </svg>
          <p>Sign In with Google</p>
        </button>

        <!-- A message area to confirm sign-in -->
        <div id="message" style="margin: 10px 0"></div>

        <!-- File input -->
        <input
          type="file"
          id="video-file"
          accept="video/*"
          style="display: none"
        />

        <!-- Video details form -->
        <div id="video-details" class="video-details" style="display: none">
          <h3>Video Details</h3>
          <div>
            <label for="video-title">Title:</label>
            <input type="text" id="video-title" value="My Demo Video Upload" />
          </div>
          <div style="margin-top: 10px">
            <label for="video-description">Description:</label>
            <textarea id="video-description" rows="3" style="width: 300px">
Uploaded from a custom front-end page!</textarea
            >
          </div>
          <div style="margin-top: 10px">
            <label for="video-privacy">Privacy:</label>
            <select id="video-privacy">
              <option value="private">Private</option>
              <option value="unlisted">Unlisted</option>
              <option value="public">Public</option>
            </select>
          </div>
        </div>

        <!-- Upload button -->
        <button
          id="upload-btn"
          onclick="uploadVideo()"
          style="margin-top: 20px; display: none"
        >
          Upload Video
        </button>

        <!-- Progress bar for upload -->
        <div
          id="progress-container"
          style="margin-top: 20px; width: 100%; max-width: 500px; display: none"
        >
          <div
            style="
              width: 100%;
              background-color: #f0f0f0;
              border-radius: 4px;
              overflow: hidden;
            "
          >
            <div
              id="progress-bar"
              style="
                height: 20px;
                width: 0%;
                background-color: #4285f4;
                transition: width 0.5s;
              "
            ></div>
          </div>
          <div id="progress-text" style="margin-top: 5px">0%</div>
        </div>

        <!-- Status message for upload results -->
        <p id="status"></p>
      </div>
    </section>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const video = document.getElementById("video");
        const timeline = document.querySelector(".timeline");
        const startHandle = document.getElementById("start-handle");
        const endHandle = document.getElementById("end-handle");
        const trimRegion = document.getElementById("trim-region");
        const playTrimmedBtn = document.getElementById("play-trimmed");
        const resetTrimBtn = document.getElementById("reset-trim");
        const downloadBtn = document.getElementById("download-btn");
        const startTimeDisplay = document.getElementById("start-time");
        const endTimeDisplay = document.getElementById("end-time");
        const videoProgress = document.getElementById("video-progress");
        const trimMethodSelect = document.getElementById("trim-method");
        const serverUrl = document.getElementById("server-url");
        const loadingIndicator = document.getElementById("loading");
        const videoListElement = document.getElementById("video-list");
        const toggleSidebarBtn = document.getElementById("toggle-sidebar");
        const leftbar = document.getElementById("leftbar");
        const centre = document.getElementById("centre");
        const rightbar = document.getElementById("rightbar");

        // Toggle sidebar functionality
        let sidebarVisible = true;
        toggleSidebarBtn.addEventListener("click", function () {
          sidebarVisible = !sidebarVisible;

          if (sidebarVisible) {
            // Show left sidebar, hide right sidebar
            leftbar.classList.remove("hidden");
            rightbar.classList.add("hidden");
            centre.classList.remove("expanded");
          } else {
            // Hide left sidebar, show right sidebar
            leftbar.classList.add("hidden");
            rightbar.classList.remove("hidden");
            centre.classList.add("expanded");
          }
        });

        let isDragging = false;
        let currentHandle = null;
        let startTime = 0;
        let endTime = 0;
        let videoDuration = 0;
        let videoFile = null;

        // Array to store video objects
        let videos = [];
        let activeVideoIndex = -1;

        // Handle video timeupdate to show progress
        video.addEventListener("timeupdate", function () {
          const progressWidth = (video.currentTime / video.duration) * 100;
          videoProgress.style.width = `${progressWidth}%`;
        });

        // Function to populate the video list
        function populateVideoList(videoArray) {
          videoListElement.innerHTML = ""; // Clear existing items
          videoArray.forEach((videoItem, index) => {
            const videoContainer = document.createElement("div");
            videoContainer.className = "video-item";
            if (index === activeVideoIndex) {
              videoContainer.classList.add("active");
            }
            videoContainer.dataset.index = index;

            // Create a video element for preview
            const videoPreview = document.createElement("video");
            videoPreview.src = videoItem.url;
            videoPreview.className = "video-preview";
            videoPreview.muted = true; // Mute to avoid auto-play issues
            videoPreview.playsInline = true; // For mobile devices
            videoPreview.preload = "metadata"; // Load minimal data for the preview
            videoPreview.controls = false; // No controls in the sidebar

            // Ensure the video stays paused after loading its data
            videoPreview.addEventListener("loadeddata", () => {
              videoPreview.pause();
            });

            // Optionally, you can add a poster image if available:
            // videoPreview.poster = videoItem.poster || '';

            // When the user clicks on the preview, load the corresponding video
            videoContainer.addEventListener("click", () => {
              loadVideo(index);
            });

            videoContainer.appendChild(videoPreview);
            videoListElement.appendChild(videoContainer);
          });
        }

        // Function to load a video into the main player
        // Find this part in the loadVideo function
        function loadVideo(index) {
          if (index < 0 || index >= videos.length) return;

          // Update active video index
          activeVideoIndex = index;
          const videoItem = videos[index];

          // Update UI to show active video
          populateVideoList(videos);

          // Load video into player
          if (videoItem.blob) {
            // Use the trimmed/local Blob if available
            video.src = URL.createObjectURL(videoItem.blob);
            videoFile = videoItem.blob;
          } else if (videoItem.url) {
            // Otherwise, use the URL version
            video.src = videoItem.url;

            // MODIFIED: Fetch the video file and convert to blob if not already available
            if (!videoFile) {
              downloadBtn.disabled = true; // Temporarily disable while fetching
              fetchVideoAsBlob(videoItem.url)
                .then((blob) => {
                  videoFile = blob;
                  downloadBtn.disabled = false; // Enable download once we have the blob
                })
                .catch((err) => {
                  console.error("Error fetching video as blob:", err);
                });
            }
          }

          // Reset positions when new video is loaded
          video.onloadedmetadata = function () {
            videoDuration = video.duration;

            // Update the duration in the video object if not set
            if (!videoItem.duration) {
              videos[index].duration = videoDuration;
              populateVideoList(videos);
            }

            resetTrimPoints();
          };
        }

        // ADD THIS FUNCTION: Helper function to fetch a video URL and return as a blob
        async function fetchVideoAsBlob(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(
                `Failed to fetch video: ${response.status} ${response.statusText}`
              );
            }
            return await response.blob();
          } catch (error) {
            console.error("Error fetching video:", error);
            throw error;
          }
        }

        // Add a video to the library
        function addVideoToLibrary(file, name = null) {
          const videoName = name || file.name || `Video ${videos.length + 1}`;

          // Create video object
          const videoObject = {
            name: videoName,
            blob: file,
          };

          // Add to videos array
          videos.push(videoObject);

          // Refresh the video list
          populateVideoList(videos);

          // Return the index of the newly added video
          return videos.length - 1;
        }

        // Format time to MM:SS
        function formatTime(timeInSeconds) {
          const minutes = Math.floor(timeInSeconds / 60);
          const seconds = Math.floor(timeInSeconds % 60);
          return `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }

        // Update time displays
        function updateTimeDisplays() {
          startTimeDisplay.textContent = formatTime(startTime);
          endTimeDisplay.textContent = formatTime(endTime);
        }

        // Update trim region visual
        function updateTrimRegion() {
          const startPos = (startTime / videoDuration) * 100;
          const endPos = (endTime / videoDuration) * 100;

          startHandle.style.left = `${startPos}%`;
          endHandle.style.left = `${endPos}%`;
          trimRegion.style.left = `${startPos}%`;
          trimRegion.style.width = `${endPos - startPos}%`;
        }

        // Reset trim points
        function resetTrimPoints() {
          startTime = 0;
          endTime = videoDuration;
          updateTrimRegion();
          updateTimeDisplays();
        }

        // Reset button
        resetTrimBtn.addEventListener("click", resetTrimPoints);

        // Mouse events for dragging handles
        startHandle.addEventListener("mousedown", function (e) {
          isDragging = true;
          currentHandle = "start";
          e.preventDefault();
        });

        endHandle.addEventListener("mousedown", function (e) {
          isDragging = true;
          currentHandle = "end";
          e.preventDefault();
        });

        document.addEventListener("mousemove", function (e) {
          if (!isDragging) return;

          const timelineRect = timeline.getBoundingClientRect();
          const posX = e.clientX - timelineRect.left;
          const posPercentage = Math.max(
            0,
            Math.min(100, (posX / timelineRect.width) * 100)
          );

          if (currentHandle === "start") {
            // Don't allow start handle to go past end handle
            const endPos = (endTime / videoDuration) * 100;
            if (posPercentage < endPos) {
              startHandle.style.left = `${posPercentage}%`;
              startTime = (posPercentage / 100) * videoDuration;
              updateTrimRegion();
              updateTimeDisplays();
            }
          } else if (currentHandle === "end") {
            // Don't allow end handle to go before start handle
            const startPos = (startTime / videoDuration) * 100;
            if (posPercentage > startPos) {
              endHandle.style.left = `${posPercentage}%`;
              endTime = (posPercentage / 100) * videoDuration;
              updateTrimRegion();
              updateTimeDisplays();
            }
          }
        });

        document.addEventListener("mouseup", function () {
          isDragging = false;
          currentHandle = null;
        });

        // Timeline click to set position
        timeline.addEventListener("click", function (e) {
          if (isDragging) return;

          const rect = timeline.getBoundingClientRect();
          const clickPos = e.clientX - rect.left;
          const clickTime = (clickPos / rect.width) * videoDuration;

          // Determine if click is closer to start or end handle
          const startDiff = Math.abs(clickTime - startTime);
          const endDiff = Math.abs(clickTime - endTime);

          if (startDiff < endDiff) {
            startTime = clickTime;
          } else {
            endTime = clickTime;
          }

          updateTrimRegion();
          updateTimeDisplays();
        });

        // Play trimmed section
        playTrimmedBtn.addEventListener("click", function () {
          video.currentTime = startTime;
          video.play();

          const checkTime = function () {
            if (video.currentTime >= endTime) {
              video.pause();
              video.removeEventListener("timeupdate", checkTime);
            }
          };

          video.addEventListener("timeupdate", checkTime);
        });

        // Client-side video trimming using MediaRecorder
        async function trimVideoClientSide(videoFile, startTime, endTime) {
          return new Promise((resolve, reject) => {
            const videoElement = document.createElement("video");
            videoElement.setAttribute("muted", "");
            videoElement.setAttribute("playsinline", "");

            const videoURL = URL.createObjectURL(videoFile);
            videoElement.src = videoURL;

            let mediaRecorder;
            let recordedChunks = [];

            videoElement.onloadedmetadata = function () {
              // Create canvas for video frames
              const canvas = document.createElement("canvas");
              canvas.width = videoElement.videoWidth;
              canvas.height = videoElement.videoHeight;
              const ctx = canvas.getContext("2d");

              // Create media stream from canvas
              const stream = canvas.captureStream();

              // Set up MediaRecorder with same MIME type if possible
              const options = { mimeType: videoFile.type };
              try {
                mediaRecorder = new MediaRecorder(stream, options);
              } catch (e) {
                // Fallback to a common format
                mediaRecorder = new MediaRecorder(stream, {
                  mimeType: "video/webm",
                });
              }

              mediaRecorder.ondataavailable = function (e) {
                if (e.data.size > 0) {
                  recordedChunks.push(e.data);
                }
              };

              mediaRecorder.onstop = function () {
                const blob = new Blob(recordedChunks, {
                  type: mediaRecorder.mimeType,
                });
                URL.revokeObjectURL(videoURL);
                resolve(blob);
              };

              // Start recording
              mediaRecorder.start();

              // Draw video frames to canvas at appropriate times
              videoElement.currentTime = startTime;

              videoElement.addEventListener(
                "timeupdate",
                function onTimeUpdate() {
                  if (videoElement.currentTime >= endTime) {
                    mediaRecorder.stop();
                    videoElement.removeEventListener(
                      "timeupdate",
                      onTimeUpdate
                    );
                    return;
                  }

                  // Draw current frame
                  ctx.drawImage(
                    videoElement,
                    0,
                    0,
                    canvas.width,
                    canvas.height
                  );
                }
              );

              videoElement.addEventListener("seeked", function onSeeked() {
                // Start playback once we've seeked to the start time
                videoElement.play();
                videoElement.removeEventListener("seeked", onSeeked);
              });
            };

            videoElement.onerror = function () {
              reject(new Error("Error loading video"));
            };
          });
        }

        // Server-side trimming function
        async function trimVideoServerSide(
          videoFile,
          startTime,
          endTime,
          serverUrl
        ) {
          const formData = new FormData();
          formData.append("video", videoFile);
          formData.append("startTime", startTime);
          formData.append("endTime", endTime);

          const response = await fetch(serverUrl, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }

          return await response.blob();
        }

        // Download trimmed video
        downloadBtn.addEventListener("click", async function () {
          if (!videoFile) {
            alert("Please upload a video first");
            return;
          }

          loadingIndicator.style.display = "inline";
          downloadBtn.disabled = true;

          try {
            let trimmedVideoBlob;
            let fileExtension = "";

            if (trimMethodSelect && trimMethodSelect.value === "client") {
              // Determine the output format based on browser support
              let mimeType = "video/webm";
              if (MediaRecorder.isTypeSupported("video/mp4")) {
                mimeType = "video/mp4";
                fileExtension = ".mp4";
              } else {
                fileExtension = ".webm";
              }

              // Use the determined mime type for recording
              trimmedVideoBlob = await trimVideoClientSide(
                videoFile,
                startTime,
                endTime,
                mimeType
              );
            } else {
              if (serverUrl) {
                trimmedVideoBlob = await trimVideoServerSide(
                  videoFile,
                  startTime,
                  endTime,
                  serverUrl.value
                );
              } else {
                // Fallback to client-side if serverUrl is not defined
                let mimeType = "video/webm";
                if (MediaRecorder.isTypeSupported("video/mp4")) {
                  mimeType = "video/mp4";
                  fileExtension = ".mp4";
                } else {
                  fileExtension = ".webm";
                }

                trimmedVideoBlob = await trimVideoClientSide(
                  videoFile,
                  startTime,
                  endTime,
                  mimeType
                );
              }

              // For server-side, get extension from original file
              if (videoFile.name) {
                fileExtension = videoFile.name.substring(
                  videoFile.name.lastIndexOf(".")
                );
              } else {
                // Default extension if name is not available
                fileExtension = ".mp4";
              }
            }

            // Create download link with proper extension
            const url = URL.createObjectURL(trimmedVideoBlob);
            const a = document.createElement("a");
            a.style.display = "none";
            a.href = url;
            a.download = "trimmed_video" + fileExtension;
            document.body.appendChild(a);
            a.click();

            setTimeout(() => {
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 100);
          } catch (error) {
            console.error("Error trimming video:", error);
            alert("Error trimming video: " + error.message);
          } finally {
            loadingIndicator.style.display = "none";
            downloadBtn.disabled = false;
          }
        });

        // Sample videos - only contain the URL as requested
        const sampleVideos = [
          {
            name: "Sample Video 1",
            url: "static/assets/card3.mp4",
          },
          {
            name: "Sample Video 2",
            url: "static/assets/card2.mp4",
          },
          {
            name: "Sample Video 3",
            url: "static/assets/card4.mp4",
          },
        ];

        // Initialize the video library with sample videos
        videos = [...sampleVideos];
        populateVideoList(videos);
        if (videos.length > 0) {
          loadVideo(0);
        }

        // Initialize with the right sidebar hidden
        rightbar.classList.add("hidden");
      });

      // Client ID and API key
      const CLIENT_ID =
        "346305436724-ndv2tg5mvduf7n2339mn9vsh0ctetfk3.apps.googleusercontent.com";
      const API_KEY = ""; // Add your API key if needed

      // YouTube API scope
      const SCOPES = "https://www.googleapis.com/auth/youtube.upload";

      let tokenClient;
      let accessToken = "";

      /**
       * Callback after the API client is loaded. Loads the discovery doc
       * to initialize the API.
       */
      function gapiLoaded() {
        gapi.load("client", initializeGapiClient);
      }

      /**
       * Initialize the API client library
       */
      async function initializeGapiClient() {
        try {
          await gapi.client.init({
            apiKey: API_KEY,
            discoveryDocs: [
              "https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest",
            ],
          });
          console.log("GAPI client initialized");
          // Update UI after initialization is complete
          document.getElementById("signin-btn").disabled = false;
        } catch (err) {
          document.getElementById("status").textContent =
            "Error initializing GAPI client: " + err.message;
          console.error("Error initializing GAPI client:", err);
        }
      }

      /**
       * Callback after Google Identity Services are loaded.
       */
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: "", // defined later
        });
        console.log("GIS loaded");
      }

      /**
       * Sign in the user upon button click.
       */
      function handleAuthClick() {
        document.getElementById("status").textContent = "Authenticating...";

        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) {
            document.getElementById("status").textContent =
              "Error: " + resp.error;
            console.error("Error signing in:", resp);
            return;
          }

          accessToken = resp.access_token;
          document.getElementById("message").textContent =
            "Signed in successfully!";
          document.getElementById("video-file").style.display = "block";
          document.getElementById("video-details").style.display = "block";
          document.getElementById("upload-btn").style.display = "block";
          document.getElementById("status").textContent =
            "Ready to upload. Please select a video file.";
          document.getElementById("signin-btn").textContent = "Change Account";
          console.log("Successfully signed in with token:", accessToken);
        };

        // Prompt the user to select an account
        if (accessToken === "") {
          tokenClient.requestAccessToken({ prompt: "consent" });
        } else {
          tokenClient.requestAccessToken({ prompt: "" });
        }
      }

      /**
       * Upload the selected video to YouTube using resumable upload
       */
      async function uploadVideo() {
        const fileInput = document.getElementById("video-file");
        const file = fileInput.files[0];
        const statusElem = document.getElementById("status");
        const progressBar = document.getElementById("progress-bar");
        const progressText = document.getElementById("progress-text");
        const progressContainer = document.getElementById("progress-container");

        if (!file) {
          alert("Please select a video file first.");
          return;
        }

        if (!accessToken) {
          alert("Please sign in first.");
          return;
        }

        // Get video details from form
        const title =
          document.getElementById("video-title").value || "Untitled Video";
        const description =
          document.getElementById("video-description").value || "";
        const privacyStatus =
          document.getElementById("video-privacy").value || "private";

        statusElem.textContent = "Starting upload process...";
        progressContainer.style.display = "block";

        try {
          // Step 1: Create the video resource metadata
          const metadata = {
            snippet: {
              title: title,
              description: description,
              tags: ["demo", "upload", "api"],
            },
            status: {
              privacyStatus: privacyStatus,
            },
          };

          console.log("Uploading with metadata:", metadata);

          // Step 2: Get a resumable upload URL
          const initResponse = await fetch(
            "https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status",
            {
              method: "POST",
              headers: {
                Authorization: "Bearer " + accessToken,
                "Content-Type": "application/json; charset=UTF-8",
                "X-Upload-Content-Type": file.type,
                "X-Upload-Content-Length": file.size,
              },
              body: JSON.stringify(metadata),
            }
          );

          if (!initResponse.ok) {
            const errorText = await initResponse.text();
            throw new Error(
              `Failed to initialize upload: ${initResponse.status} ${initResponse.statusText} - ${errorText}`
            );
          }

          // Get the resumable upload URL from the location header
          const uploadUrl = initResponse.headers.get("Location");
          if (!uploadUrl) {
            throw new Error("No upload URL returned from the server");
          }

          console.log("Got upload URL:", uploadUrl);
          statusElem.textContent =
            "Upload initialized. Uploading video data...";

          // Step 3: Upload the file in chunks for better reliability
          const chunkSize = 5 * 1024 * 1024; // 5MB chunks
          const totalChunks = Math.ceil(file.size / chunkSize);

          for (let i = 0; i < totalChunks; i++) {
            const start = i * chunkSize;
            const end = Math.min(file.size, start + chunkSize);
            const chunk = file.slice(start, end);

            const uploadResponse = await fetch(uploadUrl, {
              method: "PUT",
              headers: {
                "Content-Type": file.type,
                "Content-Range": `bytes ${start}-${end - 1}/${file.size}`,
              },
              body: chunk,
            });

            // Update progress bar
            const progress = Math.round((end / file.size) * 100);
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${progress}%`;

            // If this is the last chunk, process the response
            if (end === file.size) {
              if (
                uploadResponse.status === 200 ||
                uploadResponse.status === 201
              ) {
                const resultJson = await uploadResponse.json();
                statusElem.textContent = `Upload successful! Video ID: ${resultJson.id}`;
                console.log("Upload complete:", resultJson);

                // Add a link to view the video
                const videoLink = document.createElement("div");
                videoLink.innerHTML = `<a href="https://www.youtube.com/watch?v=${resultJson.id}" target="_blank">View Video (may still be processing)</a>`;
                statusElem.appendChild(videoLink);
              } else {
                const errorText = await uploadResponse.text();
                throw new Error(
                  `Upload failed: ${uploadResponse.status} ${uploadResponse.statusText} - ${errorText}`
                );
              }
            }
          }
        } catch (error) {
          console.error("Error uploading video:", error);
          statusElem.textContent = "Error: " + error.message;
          progressBar.style.backgroundColor = "#f44336"; // Red color for error
        }
      }

      // Load the API libraries and set up authentication
      window.onload = function () {
        document.getElementById("signin-btn").disabled = true;
        gapiLoaded();
        gisLoaded();
      };
    </script>
  </body>
</html>
